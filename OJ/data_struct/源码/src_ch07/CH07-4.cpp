/*********************************************
*  P231 算法7.4  冒泡排序算法（交换排序算法）
**********************************************/
// 冒泡排序算法：对长度为num的序列R按关键字升序进行冒泡排序
// 参数说明：待排序序列为R[1..num]，Dist[0..len-1]为增量序列
// 待排序列从数组R下标为1的位置开始存储，数组R长度为num+1
// R[0]用于临时存储待插入的元素，从第二个位置处的记录开始排序

void sort_bubble(int R[], int num){
    int i, j, flag;
    for( i = 1; i < num; ++i ){
        flag = 0;  // 交换标志，冒泡过程中发生元素交换时置1
        for( j = 1; j <= (num-i); ++j ){
            // 若出现逆序（不满足升序规则），则进行元素交换
            if( R[j] > R[j+1] ){  
                R[0] = R[j+1]; // 利用R[0]暂存元素
                R[j+1] = R[j];
                R[j] = R[0];
                flag = 1;     // 设置交换标志为1
            }            
        }
        // 若本轮冒泡过程中未发生元素交换，则排序结束
        if( flag == 0) break; 
    }
}

// 改进的冒泡排序算法
// 增设一个lastxid变量，用于跟踪记录最后一次交换发生的位置
void sort_bubble_fast(int R[], int num){
    int i, j, flag, lastxid;
    for( i = 1; i < num; ++i ){
        flag = 0;  // 交换标志，冒泡过程中发生元素交换时置1
        lastxid = 1;
        for( j = 1; j <= (num-i); ++j ){
            // 若出现逆序（不满足升序规则），则进行元素交换
            if( R[j] > R[j+1] ){  
                R[0] = R[j+1];  // 利用R[0]暂存元素
                R[j+1] = R[j];
                R[j] = R[0];
                lastxid = j;     // 记录元素交换发生的位置
                flag = 1;           // 设置交换标志为1
            }            
        }
        // 若本轮冒泡过程中未发生元素交换，则排序结束
        if( flag == 0) break; 
        i = lastxid;  // 本轮冒泡最后一次元素交换发生的位置
    }
}