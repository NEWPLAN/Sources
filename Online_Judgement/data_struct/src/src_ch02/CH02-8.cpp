/*************************************
 *  教材P46：栈的顺序存储结构
**************************************/

# define MAXSIZE 100
typedef int EntryType;
 
/*************************************
 * 定义顺序栈的数据类型
 * 说明：若约定top = -1表示空栈；则top = MAXSIZE-1表示栈满
**************************************/
typedef struct stack{
   int top;                                   // 存放栈顶位置
   EntryType entry[MAXSIZE]; // 存放数据元素
}Stack, *StackPtr;

/*************************************
 * 教材P47：栈的初始化1：静态分配存储空间
**************************************/
Stack s;  // 首先声明堆栈变量s

int stack_init(Stack s){
   s.top = -1;  // 空栈，元素个数为零
   return 0;
}

/*************************************
 * 教材P47：栈的初始化2：动态分配存储空间
**************************************/

int stack_init(StackPtr *s){
    int status = -1;
    StackPtr ps;    // 首先声明一个指向栈的指针
    
    ps = (StackPtr) malloc (sizeof (Stack) )  // 为堆栈分配存储空间
   
    if (ps){                    // 若空间分配成功
        ps -> top = -1;    // 空栈，元素个数为零
        *s = ps;               // 通过函数参数返回堆栈存储空间的首地址
        status = 0;
    }
    return status;
}

/*************************************
 * 教材P48：栈的销毁（释放栈的存储空间）
 * 注意：适用于顺序栈，链栈的销毁需要另外编写销毁函数
**************************************/
void stack_destroy(StackPtr *s) {
	if(*s) {              // 首先判断栈的存储空间是否存在
		free (*s);
		*s = NULL;
	}
}

/*************************************
 * 教材P48：栈的清空（清除栈中存放的数据元素）
 * 栈中存放的有效数据由栈顶指针指示，与栈空间中存储的值无关
**************************************/
void stack_clear(StackPtr s){
	s -> top = -1;
}

/*************************************
 * 教材P48：判空
**************************************/
bool stack_empty(StackPtr s){
	return (s -> top <= -1);
}

/*************************************
 * 教材P48：判满
**************************************/
bool stack_full(StackPtr s){
	return (s -> top >= MAXSIZE -1);
}
